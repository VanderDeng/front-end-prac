for (var k in obj){
    k得到的是属性名
    obj[k]得到的是属性值
}

4.H5自定义属性
目的：为了保存数据并使用，有些数据可以保存到页面中而不是数据库中

data-开头为自定义属性
div.setAttribute('data-time',20)
获取属性方法：getArrtibute或者div.dataset.index

5.节点操作
网页中的所有内容都是节点，在dom中节点用node表示，html dom树中的所有节点均可以通过js进行访问，所有html元素也可以被修改创建或者删除。
父节点：xxx.parentNode 得到的是离元素最近的父节点，没有则返回null
子节点：ul.childNodes 包含元素节点和文本节点。需要用for循环遍历取出nodetype =1 取出。所以一般使用：ul.children即可。其中还有：firstElementChild,lastElementChild(IE9以上支持)。解决方案实际开发：ol.children[0],最后一个用ol.children.length-1。
兄弟节点：.nextElementSibling .previousElementSibling
创建节点：1.创建节点元素 var li = document.creatElement('li') ; var ul = document.querySelector('ul');  ul.appendChild(li);
添加节点：node.insertBefore(child, 元素)
删除节点：node.removeChild(child) 
*组织链接跳转javascript:;
复制节点：node.cloneNode(true)
*不同浏览器下innerHTML（不要用拼接字符串，采取数组的形式）效率要比creatElement高

**DOM重点核心**
    文档对象模型（Document Objecgt Model），是w3c组织推荐的处理可扩展标记语言（html）的标准编程接口
    w3c已经定义了一系列的dom接口，通过这些dom接口可以改变网页的内容，结构和样式。dom使html形成了domtree，获取dom是对象。
    1.创建
    creatElement
    2.增加
    appendChild,insertBefore
    3.删除
    removeChild
    4.改
    innerHTML,style,value,href
    5.查
    querySelector; 节点操作
    6.属性操作
    setAttribute, getAttribute
    7.事件
    onclick,onmouseover, onmouseout, onfocus, onblur...（addEventListener, removeEventListener）

    *DOM事件流
    捕获阶段：document-element-element body-element div; dom事件流事件：elementbody-element div; 冒泡阶段：倒序
    addaddEventListener(",function(),true)则是捕获阶段，如果是false则是冒泡阶段。事件会根据dom进行传播，。实际开发中更关注冒泡
    onblur,onfocus等没有冒泡。

兼容处理：div.onclick function(){
            e = e || window.event;}

6. 常见事件对象触发：
    e.target触发事件的对象
    e.type返回事件的类型
    e.preventDefault()阻止行为
    return false;(没有版本兼容问题，但是后面所有的代卖都不执行)
    *阻止冒泡：e.stopPropagation();低版本cancelBubble
    *事件代理：不是每个子节点单独设置事件监听器，而是把事件监听器设置在父节点上，然后利用冒泡远离影响设置每个子节点。只操作了一次dom提高了性能

7.常用鼠标事件
    1.document.addaddEventListener('contextmenu', function(e){ 
        e.preventDefault();
    })  //取消默认的上下文菜单
    2.document.addaddEventListener('selectstar', function(e){ 
    e.preventDefault();
    }) //禁止选中文字

**BOM**
    浏览器对象模型，提供了独立于内容而与浏览器窗口进行交互的对象。window对象是浏览器的顶级对象。

8.常用键盘事件
    1.keyup, keydown, keypress判断按下
    2.keyCode判断用户具体案件

**this指向问题**
一般指向调用它的对象
1.全局作用域或者普通函数中的this指向全局对象this
2.方法中调用的this

**js执行机制**
先执行执行栈中的同步任务，异步任务放到任务队列中。先把执行栈中的任务执行完毕再去任务队列执行，把队列中的任务放在执行栈之后。
事件循环：主线程不断的重复获得任务，执行任务。

源码分析案例：
（function flexible(window,document){}()) 立即执行函数，创建了一个独立的作用域，里面变量都是局部变量
var docEl = docment.documenteElement 获取根元素
var dpr = window.devicePixelRatio || 1  物理像素比
这是body字体大小：
function setBodyFontSize(){}  大小*dpr + ‘px’
function ()v{     //设置html元素的文字大小
    ar rem = docEL.clientWidth/10
docEl.style.fontsize = rem + 'px'}

pageshow事件可以兼容火狐浏览器：window.addaddEventListener('pageshow', function(e){
    // e.prsisted返回的的是true，是说如果这个页面是从缓存取过来的页面也需要重新机选一下rem大小。
    if(e.persisted){
        setRemUnit()
    }
})

三大系列：
offset获取元素位置 offsetLeft offsetTop
client常用于获取元素大小 clientWidth ClientHeight
scroll 常用于获取滚动距离 scrollTop scrollLeft; window.pageXOffset获得页面滚动距离

mouseover: 经过自身盒子会触发，经过子盒子还会触发
mouseenter: 只会触发自身盒子， 不会冒泡

缓动动画公式：（目标值-现在的位置）- 10

节流阀：让上一个动画执行完毕再执行下一个动画
var flag = true;
if(flag){flag = false; do sth}
利用回调函数，动画执行完毕：flag = true

轮播图p125

短路运算符：callback && callback(); 先判断callback的true false

**移动端开发**
滚动过渡效果：ul.style.transition = 'all .3s'， 滚动效果ul.style.transform 
classList H5新属性 classList[0]拿回第一个类名 ：
div.classList.add('three'); div.classList.remove('three'); *div.class.toggle('bg')自动判断有则去掉，没有则加上。
click延时解决方案：
1.<meta name = "viewport" content = "user-scalable = no">
2. 利用touch事件自己封装300ms延迟，记录当前触摸时间，离开时间-触摸时间 < 150ms 并且没有滑动则定义为点击。
3. js插件 swiper superslide iscroll zy.media

前端框架：一整套的解决方案。 插件：某个功能的解决方案。

本地存储：
sessionStorage:生命周期为关闭浏览器窗口，同一个窗口下数据可以共享。
localStorage:生命周期永久，同一个浏览器可以共享，都是键值对形式储存。


**jQuery**
$(function ()){  //入口函数
    $('div').hide();
}
*DOM对象：用原生js获取过来的对象。  jQuery对象是个伪数组


**Vue**
Vue会管理el选项命中的元素及其内部的后代元素，建议使用id选择器。









    











